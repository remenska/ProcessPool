%%% START HERE
sort TaskFunction = struct RegisterFile | RemoveFile | LogUpload;
sort Task = struct task(id:Nat,blocking:Bool,timeOut:Nat, taskFunction:TaskFunction) | None;
sort Worker = struct W(id:Nat,isWorking:Bool);
sort ReturnMessage = struct S_OK | S_ERROR;
% FIXED Error while exploring state space: Expression !(0 < #tail([])) does not rewrite to true or false in the condition 
%if(e7_WorkingProcess_while2, if(e6_WorkingProcess_while2, s10_WorkingProcess_while2 == 14 && !(!stopEvent_WorkingProcess_while2 &&
% #__pendingQueue_Queues_mem > 0), s10_WorkingProcess_while2 == 14 && !stopEvent_WorkingProcess_while2 && #__pendingQueue_Queues_mem > 0), 
%if(e6_WorkingProcess_while2, s10...
% This is because "Note that the head and tail of an empty list are undefined, so that mCRL2 will not further reduce the terms head([]) and tail([])"


% BEGIN ProcessPool maps
% ================================
map mapGetNumWorkingProcesses: List(Worker) -> Nat;
var
    listWorkers:List(Worker);
    el:Worker;

eqn
    mapGetNumWorkingProcesses([]) = 0;
    isWorking(el) -> mapGetNumWorkingProcesses(el|>listWorkers) = 1 + mapGetNumWorkingProcesses(listWorkers);
    !(isWorking(el)) -> mapGetNumWorkingProcesses(el|>listWorkers) = mapGetNumWorkingProcesses(listWorkers);

% =================================
map mapGetNumIdleProcesses: List(Worker) -> Nat;
var
    listWorkers:List(Worker);
    el:Worker;

eqn
    mapGetNumIdleProcesses([]) = 0;
    isWorking(el) -> mapGetNumIdleProcesses(el|>listWorkers) = mapGetNumIdleProcesses(listWorkers);
    !(isWorking(el)) -> mapGetNumIdleProcesses(el|>listWorkers) = 1 + mapGetNumIdleProcesses(listWorkers);
% =================================

map mapSetWorking: Nat#Bool#List(Worker) -> List(Worker);
var
  listWorkers, updatedList:List(Worker);
  el:Worker;
  wpid,n:Nat;
  isWorking:Bool;

eqn
    mapSetWorking(wpid, isWorking, []) = [];
    (listWorkers!=[] && id(head(listWorkers))==wpid) ->  
	mapSetWorking(wpid, isWorking, listWorkers) = W(wpid, isWorking)|> mapSetWorking(wpid, isWorking, tail(listWorkers));
    (listWorkers!=[] && id(head(listWorkers))!=wpid) -> 
	mapSetWorking(wpid, isWorking, listWorkers) = head(listWorkers)|> mapSetWorking(wpid, isWorking, tail(listWorkers));


% =================================
% END ProcessPool maps
% ================================


%% ============ ProcessPool
act r_getMaxSize, s_getMaxSize, getMaxSize:Nat;
act r_getMinSize, s_getMinSize, getMinSize:Nat;
act r_getNumWorkingProcesses, s_getNumWorkingProcesses, getNumWorkingProcesses:Nat;
act r_getNumIdleProcesses, s_getNumIdleProcesses, getNumIdleProcesses:Nat;


act s__prListLock_acquire,r__prListLock_acquire,__prListLock_acquire;
act s__prListLock_release,r__prListLock_release,__prListLock_release;



act s_getRequestsPerCycle, r_getRequestsPerCycle, getRequestsPerCycle:Nat;
act s_getMinProcess, r_getMinProcess, getMinProcess:Nat;
act s_getMaxProcess, r_getMaxProcess, getMaxProcess:Nat;
act s_getQueueSize, r_getQueueSize, getQueueSize:Nat;
act s_getRequest, r_getRequest, getRequest:Task;

act blah,RequestExecutingAgent_return;
act createProcessPool;

% BEGIN RequestExecutingAgent processes

proc RequestExecutingAgent_mem(__requestsPerCycle:Nat, minProcess:Nat, maxProcess:Nat, queueSize:Nat) = 
      r_getRequestsPerCycle(__requestsPerCycle).
     RequestExecutingAgent_mem(__requestsPerCycle, minProcess, maxProcess, queueSize) 
      + 
     r_getMaxProcess(maxProcess).
     RequestExecutingAgent_mem(__requestsPerCycle, minProcess, maxProcess, queueSize) 
      +
     r_getMinProcess(minProcess).
     RequestExecutingAgent_mem(__requestsPerCycle, minProcess, maxProcess, queueSize) 
      +
     r_getQueueSize(queueSize).
 RequestExecutingAgent_mem(__requestsPerCycle, minProcess, maxProcess, queueSize) 
;


% todo CreateProcessPool
proc RequestExecutingAgent = RequestExecutingAgent_mem(10,1,8,10) || processPoolSingleton || RequestExecutingAgent_execute(0);

proc processPoolSingleton = 
ProcessPool_mem(processPoolTuple(1,8,10,[W(1,false),W(2,false)],false)) || ProcessPool_createAndQueueTask
;

% RequestExecutingAgent method
proc RequestExecutingAgent_execute(taskCounter:Nat) =
    sum requestsPerCycle:Nat.s_getRequestsPerCycle(requestsPerCycle).
      (taskCounter<requestsPerCycle) -> (
	 sum newTask:Task.s_getRequest(newTask).
	  % TODO:  self.cacheRequest( request )
	  c_s_getNumIdleProcesses.sum numIdle:Nat.r_r_getNumIdleProcesses(numIdle).
	  c_s_getNumWorkingProcesses.sum numWorking:Nat.r_r_getNumWorkingProcesses(numWorking).
	  RequestExecutingAgent_execute_while(taskCounter, newTask)
	 
	).RequestExecutingAgent_execute(taskCounter+1) <> RequestExecutingAgent_return; 

% RequestExecutingAgent method

act s_getFreeSlots, r_getFreeSlots, getFreeSlots:Nat;
act c_s_createAndQueueTask, c_r_createAndQueueTask, c__createAndQueueTask:Task;
act r_s_createAndQueueTask, r_r_createAndQueueTask, r__createAndQueueTask:ReturnMessage;

act time_sleep;    % temporary actions, TODO: rework them
proc RequestExecutingAgent_execute_while(taskCounter:Nat, newTask:Task) = 
    sum freeSlots:Nat.s_getFreeSlots(freeSlots).
    (freeSlots==0) -> (
    time_sleep.RequestExecutingAgent_execute_while(taskCounter, newTask) 
    ) <> c_s_createAndQueueTask(newTask).sum retMsg:ReturnMessage.r_r_createAndQueueTask(retMsg)
;

% TODO: move it in ProcessPool processes category
% ProcessPool method
proc ProcessPool_createAndQueueTask = 
    sum newTask:Task.c_r_createAndQueueTask(newTask).
    s__prListLock_acquire.  
% TODO  except Queue.Full:
%       self.__prListLock.release()
%       return S_ERROR( "Queue is full" ) % <-- since I'm not using the return value higher in the call hierarchy, maybe it's not that useful? 
    s___pendingQueuePut(newTask).
    s__prListLock_release.
  % TODO do tuka sum: __spawnNeededWorkingProcesses
    r_s_createAndQueueTask(S_OK)

.ProcessPool_createAndQueueTask
;

% proc CreateProcessPool = createProcessPool;
%% creates tasks....
proc RequestClient = 
    r_getRequest(task(1,true,10, LogUpload))
.RequestClient
;

% END RequestExecutingAgent processes




act c_s_getNumWorkingProcesses, c_r_getNumWorkingProcesses, c__getNumWorkingProcesses;
act r_s_getNumWorkingProcesses, r_r_getNumWorkingProcesses, r__getNumWorkingProcesses:Nat;
act c_s_getNumIdleProcesses, c_r_getNumIdleProcesses, c__getNumIdleProcesses;
act r_s_getNumIdleProcesses, r_r_getNumIdleProcesses, r__getNumIdleProcesses:Nat; 
    
sort ProcessPoolTuple = struct processPoolTuple(__minSize:Nat,__maxSize:Nat,__maxQueuedRequests:Nat, __workersDict:List(Worker), __draining:Bool);

% BEGIN ProcessPool processes ========

% ProcessPool memory
proc ProcessPool_mem(ppt:ProcessPoolTuple) = 
        r_getMaxSize(__maxSize(ppt)).
	  ProcessPool_mem(ppt)
        +
        r_getMinSize(__minSize(ppt)).
        ProcessPool_mem(ppt)
	+
	r_getNumWorkingProcesses(mapGetNumWorkingProcesses(__workersDict(ppt))).
	ProcessPool_mem(ppt)
	+
	r_getNumIdleProcesses(mapGetNumIdleProcesses(__workersDict(ppt))).
	ProcessPool_mem(ppt)
	+
	sum wpid:Nat,working:Bool.r_set__working1(wpid, working). 
       ProcessPool_mem(processPoolTuple(__minSize(ppt), __maxSize(ppt), __maxQueuedRequests(ppt), mapSetWorking(wpid, working, __workersDict(ppt)), __draining(ppt)))
	+
	r_getFreeSlots( max(0, Int2Nat(__maxSize(ppt) -  mapGetNumWorkingProcesses(__workersDict(ppt) )))).
      ProcessPool_mem(ppt)
;


% proc ProcessPool = Proc_getNumWorkingProcesses.Proc_getNumIdleProcesses.ProcessPool;

proc __prListLock = 
	r__prListLock_acquire.
	r__prListLock_release.
__prListLock;

proc ProcessPool = c_s_getNumWorkingProcesses.sum numWorking:Nat.r_r_getNumWorkingProcesses(numWorking).ProcessPool; % TODO: probably won't need this, just how-to-use
proc ProcessPool1 = c_s_getNumIdleProcesses.sum numIdle:Nat.r_r_getNumIdleProcesses(numIdle).ProcessPool1; % TODO: probably won't need this

% ProcessPool method
proc Proc_getNumWorkingProcesses = 
  c_r_getNumWorkingProcesses.
  s__prListLock_acquire. 
    sum wp:Nat.s_getNumWorkingProcesses(wp).
  s__prListLock_release.
  r_s_getNumWorkingProcesses(wp).
Proc_getNumWorkingProcesses
;

% ProcessPool method
proc Proc_getNumIdleProcesses = 
  c_r_getNumIdleProcesses.
  s__prListLock_acquire. 
    sum wp:Nat.s_getNumIdleProcesses(wp).
  s__prListLock_release.
r_s_getNumIdleProcesses(wp).
Proc_getNumIdleProcesses
;
  
% END ProcessPool processes ========


%% ============ START WorkingProcess
act r_isWorking, s_isWorking, isWorking:Bool;
act r_taskProcessed, s_taskProcessed, taskProcessed:Nat;
act r_runWatchdogThread, s_runWatchdogThread, runWatchdogThread:Nat#Nat;
act doSomethingWatchdog:Nat#Nat;
act doSomethingWorkingProcess;
act r_set__working, r_set__working1, s_set__working, set__working:Nat#Bool;
act r_runProcessThread, s_runProcessThread, runProcessThread:Nat#Nat;
act r_setTask, s_setTask, setTask:Nat#Task;
act processTask, runWorkingProcess, createProcessThread, return;
act r_increaseTaskCounter, s_increaseTaskCounter, increaseTaskCounter:Nat;
act r_getStopEvent, s_getStopEvent, getStopEvent:Bool;
act r_clearTask, s_clearTask, clearTask:Nat;
act r_joinProcessThread, s_joinProcessThread, joinProcessThread;
act r___pendingQueueGet, s___pendingQueueGet, __pendingQueueGet:Task;
act r___pendingQueuePut, s___pendingQueuePut, __pendingQueuePut:Task;

act r___resultsQueuePut, s___resultsQueuePut, __resultsQueuePut:Task;
act r___pendingQueueSize, s___pendingQueueSize, __pendingQueueSize:Nat;
act r_setStopEvent, s_setStopEvent, setStopEvent:Bool;

%%% ============= START Memory for queueues, these are shared between the ProcessPool and the Workers, this is how they communicate

proc Queues_mem(__pendingQueue:List(Task),__resultsQueue:List(Task),__stopEvent:Bool) =   
   (__pendingQueue!=[])-> r___pendingQueueGet(head(__pendingQueue)). 
    Queues_mem(tail(__pendingQueue), __resultsQueue, __stopEvent)
  +
  (__pendingQueue==[])-> r___pendingQueueGet(None). 
    Queues_mem(__pendingQueue, __resultsQueue, __stopEvent)
   + 
   sum newTask:Task.r___resultsQueuePut(newTask).
    Queues_mem(__pendingQueue, __resultsQueue<|newTask, __stopEvent) 
      +
    r___pendingQueueSize(#__pendingQueue).
    Queues_mem(__pendingQueue, __resultsQueue, __stopEvent) 
      +
     r_getStopEvent(__stopEvent). % TODO: this belongs to Agent, right? it's just passed to WorkingProcess
    Queues_mem(__pendingQueue, __resultsQueue, __stopEvent)
      +
    sum newStopEvent:Bool.r_setStopEvent(newStopEvent).
    Queues_mem(__pendingQueue, __resultsQueue, newStopEvent)
      +
    sum newTask:Task.r___pendingQueuePut(newTask).
    Queues_mem(__pendingQueue<|newTask, __resultsQueue, __stopEvent)
    
;

%%% ============= END Memory for queueues

% BEGIN WorkingProcess processes
% 
%%% WorkingProcess Memory

sort WorkingProcessTuple = struct workingProcessTuple(wpid:Nat, __working:Bool,__taskCounter:Nat,__watchdogThread:Nat, __processThread:Nat,task:Task);


proc WorkingProcess_mem(wpt:WorkingProcessTuple) = 
      r_isWorking(__working(wpt)).
      WorkingProcess_mem(wpt)
    +
      r_taskProcessed(__taskCounter(wpt)). % tell how many tasks have been processed so far
      WorkingProcess_mem(wpt)
    +
       sum working:Bool.r_set__working(wpid(wpt), working). 
       WorkingProcess_mem(workingProcessTuple(wpid(wpt), working, __taskCounter(wpt), __watchdogThread(wpt), __processThread(wpt), task(wpt)))
    +
      sum newTask:Task.r_setTask(wpid(wpt), newTask).
     WorkingProcess_mem(workingProcessTuple(wpid(wpt), __working(wpt), __taskCounter(wpt), __watchdogThread(wpt), __processThread(wpt), newTask))
    +
      r_increaseTaskCounter(wpid(wpt)). % TUKA!!!
     WorkingProcess_mem(workingProcessTuple(wpid(wpt), __working(wpt), (__taskCounter(wpt)+1), __watchdogThread(wpt), __processThread(wpt), task(wpt)))
    + 
     r_clearTask(wpid(wpt)).
    WorkingProcess_mem(workingProcessTuple(wpid(wpt), __working(wpt), __taskCounter(wpt), __watchdogThread(wpt), __processThread(wpt), None))
;

proc WatchdogThread(wpid:Nat, wdtid:Nat) = doSomethingWatchdog(wpid,wdtid).WatchdogThread(wpid,wdtid);  %% TODO: change if os.getppid() == 1:

proc ProcessThread(wpid:Nat, ptid:Nat)= runProcessThread(wpid,ptid).processTask;

proc WorkingProcess(wpid:Nat) = WorkingProcess_start(wpid) || WorkingProcess_mem(workingProcessTuple(wpid,false,0,1,1,None));

%WorkingProcess_start(wpid:Nat) = s_runWatchdogThread(wpid, 1);
proc WorkingProcess_start(wpid:Nat) = runWorkingProcess.WatchdogThread(wpid, 1) || % TODO: like this or with s_runWatchdogThread ?
				WorkingProcess_while(wpid)
				;

proc WorkingProcess_while(wpid:Nat) = 
			sum stopEvent:Bool.s_getStopEvent(stopEvent).sum pqSize:Nat.s___pendingQueueSize(pqSize).
				(!stopEvent && pqSize>0) -> (
					  s_clearTask(wpid).
					  s_set__working(wpid, true).
					  sum task:Task.s___pendingQueueGet(task). %TODO: missing if task==None %TODO: swap steps with the one above?
					  s_setTask(wpid, task). 
					  ProcessThread(wpid,1).			    
					  joinProcessThread.
      %             if not self.task.taskResults() and not self.task.taskException():
					  s___resultsQueuePut(task).
					  s_increaseTaskCounter(wpid).
					  s_set__working(wpid, false)
				). WorkingProcess_while(wpid)
				<> return 
				;
				    
% END WorkingProcess processes

% init block(  { r_getMaxSize, s_getMaxSize, r_getMinSize, s_getMinSize,
% 	  r_getNumWorkingProcesses,s_getNumWorkingProcesses,
% 	  r_getNumIdleProcesses,s_getNumIdleProcesses,
% 	  s__prListLock_acquire, r__prListLock_acquire,
% 	  s__prListLock_release, r__prListLock_release,
% 	  s_isWorking, r_isWorking,
% 	  s_taskProcessed, r_taskProcessed,
% 	  s_runWatchdogThread, r_runWatchdogThread,
% 	  s_set__working, r_set__working,
% 	  r_setTask, s_setTask,
% 	  r_increaseTaskCounter, s_increaseTaskCounter,
% 	  r_runProcessThread, s_runProcessThread,
% 	  r_getStopEvent, s_getStopEvent,
% 	  r_clearTask, s_clearTask,
% 	  r_joinProcessThread, s_joinProcessThread,
% 	  r___pendingQueueGet, s___pendingQueueGet,
% 	  r___resultsQueuePut, s___resultsQueuePut,
% 	  r___pendingQueueSize, s___pendingQueueSize,
% 	  r_setStopEvent, s_setStopEvent,
% 	  s_getRequestsPerCycle, r_getRequestsPerCycle,
% 	  s_getMinProcess, r_getMinProcess,
% 	  s_getMaxProcess, r_getMaxProcess,
% 	  s_getQueueSize, r_getQueueSize,
% 	  s_getRequest, r_getRequest
% 	  },

init allow(  { getMaxSize, getMinSize,
	  getNumWorkingProcesses,
	  getNumIdleProcesses,
	  __prListLock_acquire,
	  __prListLock_release,
	  isWorking,
	  taskProcessed,
	  runWatchdogThread,
	  set__working,
	  setTask,
	  increaseTaskCounter,
	  runProcessThread,
	  getStopEvent,
	  clearTask,
	  joinProcessThread,
	  __pendingQueueGet,
	  __resultsQueuePut,
	  __pendingQueueSize,
	  setStopEvent,
	  getRequestsPerCycle,
	  getMinProcess,
	  getMaxProcess,
	  getQueueSize,
	  getRequest,
	  return,
	  c__getNumWorkingProcesses,
	  r__getNumWorkingProcesses,
	  c__getNumIdleProcesses,
	  r__getNumIdleProcesses,
	  runWorkingProcess,
	  processTask,
	  doSomethingWatchdog,
	  RequestExecutingAgent_return,
	  getFreeSlots,
	  c__createAndQueueTask, 
	  r__createAndQueueTask,
	  time_sleep,
	  __pendingQueuePut
	  },
       comm( { r_getMaxSize|s_getMaxSize->getMaxSize,
        r_getMinSize | s_getMinSize -> getMinSize,
        r_getNumWorkingProcesses | s_getNumWorkingProcesses -> getNumWorkingProcesses,
        r_getNumIdleProcesses | s_getNumIdleProcesses -> getNumIdleProcesses,
        s__prListLock_acquire | r__prListLock_acquire -> __prListLock_acquire,
        s__prListLock_release | r__prListLock_release -> __prListLock_release,
        s_isWorking | r_isWorking -> isWorking,
        s_taskProcessed | r_taskProcessed -> taskProcessed,
        s_runWatchdogThread | r_runWatchdogThread -> runWatchdogThread,
	s_set__working | r_set__working | r_set__working1 -> set__working,
	r_setTask | s_setTask -> setTask,
	r_increaseTaskCounter | s_increaseTaskCounter -> increaseTaskCounter,
	r_runProcessThread | s_runProcessThread -> runProcessThread,
	r_getStopEvent | s_getStopEvent -> getStopEvent,
	r_clearTask | s_clearTask -> clearTask,
	r_joinProcessThread | s_joinProcessThread -> joinProcessThread,
	r___pendingQueueGet | s___pendingQueueGet -> __pendingQueueGet,
	r___resultsQueuePut |  s___resultsQueuePut -> __resultsQueuePut,
	r___pendingQueueSize | s___pendingQueueSize -> __pendingQueueSize,
	r_setStopEvent | s_setStopEvent -> setStopEvent,
	s_getRequestsPerCycle | r_getRequestsPerCycle -> getRequestsPerCycle,
	s_getMinProcess | r_getMinProcess -> getMinProcess,
	s_getMaxProcess | r_getMaxProcess -> getMaxProcess,
	s_getQueueSize | r_getQueueSize -> getQueueSize,
	s_getRequest | r_getRequest -> getRequest,
	c_s_getNumWorkingProcesses | c_r_getNumWorkingProcesses -> c__getNumWorkingProcesses,
	r_s_getNumWorkingProcesses | r_r_getNumWorkingProcesses -> r__getNumWorkingProcesses,
	r_s_getNumIdleProcesses | r_r_getNumIdleProcesses -> r__getNumIdleProcesses,
	c_s_getNumIdleProcesses | c_r_getNumIdleProcesses -> c__getNumIdleProcesses,
	s_getFreeSlots | r_getFreeSlots -> getFreeSlots,
	c_s_createAndQueueTask | c_r_createAndQueueTask -> c__createAndQueueTask,
	r_s_createAndQueueTask | r_r_createAndQueueTask -> r__createAndQueueTask,
	r___pendingQueuePut | s___pendingQueuePut ->  __pendingQueuePut
       },
       %% === Agent stuff
       RequestExecutingAgent || RequestClient ||
       
       %% ==== ProcessPool stuff
%         ProcessPool || ProcessPool1 ||
% 	ProcessPool_mem(processPoolTuple(1,8,10,[W(1,false),W(2,false)],false)) ||
	 __prListLock || 
	 Proc_getNumWorkingProcesses || Proc_getNumIdleProcesses || 

	%% ==== WorkingProcess'es stuff
%          WorkingProcess(1) || WorkingProcess(2) ||

% 	__pendingQueue:List(Task),__resultsQueue:List(Task),__stopEvent:Bool
        Queues_mem([task(1,true,10, RegisterFile),task(2,true,10, RemoveFile)],[],false) 
%         ProcessPool || %% TODO: Enable again
        %% === WorkingProcess stuff
% 	wpid:Nat, __working:Bool,__taskCounter:Nat,__watchdogThread:Nat, __processThread:Nat,task:Task
     ));
     
     
