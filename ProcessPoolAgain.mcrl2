%%% START HERE
sort TaskFunction = struct RegisterFile | RemoveFile | LogUpload;
sort Task = struct task(id:Nat,blocking:Bool,timeOut:Nat, taskFunction:TaskFunction) | None;
sort Worker = struct W(id:Nat,isWorking:Bool);


% ================================
map mapGetNumWorkingProcesses: List(Worker) -> Nat;
var
    listWorkers:List(Worker);
    el:Worker;

eqn
    mapGetNumWorkingProcesses([]) = 0;
    isWorking(el) -> mapGetNumWorkingProcesses(el|>listWorkers) = 1 + mapGetNumWorkingProcesses(listWorkers);
    !(isWorking(el)) -> mapGetNumWorkingProcesses(el|>listWorkers) = mapGetNumWorkingProcesses(listWorkers);

% =================================
map mapGetNumIdleProcesses: List(Worker) -> Nat;
var
    listWorkers:List(Worker);
    el:Worker;

eqn
    mapGetNumIdleProcesses([]) = 0;
    isWorking(el) -> mapGetNumIdleProcesses(el|>listWorkers) = mapGetNumIdleProcesses(listWorkers);
    !(isWorking(el)) -> mapGetNumIdleProcesses(el|>listWorkers) = 1 + mapGetNumIdleProcesses(listWorkers);
% =================================



%% ============ ProcessPool
act r_getMaxSize, s_getMaxSize, getMaxSize:Nat;
act r_getMinSize, s_getMinSize, getMinSize:Nat;
act r_getNumWorkingProcesses, s_getNumWorkingProcesses, getNumWorkingProcesses:Nat;
act r_getNumIdleProcesses, s_getNumIdleProcesses, getNumIdleProcesses:Nat;


act s__prListLock_acquire,r__prListLock_acquire,__prListLock_acquire;
act s__prListLock_release,r__prListLock_release,__prListLock_release;

proc __prListLock = 
	r__prListLock_acquire.
	r__prListLock_release.
__prListLock;

%%%%%%% ========== RequestExecutingAgent 

act s_getRequestsPerCycle, r_getRequestsPerCycle, getRequestsPerCycle:Nat;
act s_getMinProcess, r_getMinProcess, getMinProcess:Nat;
act s_getMaxProcess, r_getMaxProcess, getMaxProcess:Nat;
act s_getQueueSize, r_getQueueSize, getQueueSize:Nat;
act s_getRequest, r_getRequest, getRequest:Task;

act blah,RequestExecutingAgent_return;
act createProcessPool;

proc RequestExecutingAgent_mem(__requestsPerCycle:Nat, minProcess:Nat, maxProcess:Nat, queueSize:Nat) = 
      r_getRequestsPerCycle(__requestsPerCycle).
     RequestExecutingAgent_mem(__requestsPerCycle, minProcess, maxProcess, queueSize) 
      + 
     r_getMaxProcess(maxProcess).
     RequestExecutingAgent_mem(__requestsPerCycle, minProcess, maxProcess, queueSize) 
      +
     r_getMinProcess(minProcess).
     RequestExecutingAgent_mem(__requestsPerCycle, minProcess, maxProcess, queueSize) 
      +
     r_getQueueSize(queueSize).
 RequestExecutingAgent_mem(__requestsPerCycle, minProcess, maxProcess, queueSize) 
;


% todo CreateProcessPool
proc RequestExecutingAgent = RequestExecutingAgent_execute(0) || RequestExecutingAgent_mem(10,1,8,10) ;

proc processPoolMethod = 
%   sum initialized:Bool.(initialized==false)->
%       (ProcessPool_mem(1,8,10,[],false, true) || CreateProcessPool 
%       ) <> 
return;

proc RequestExecutingAgent_execute(taskCounter:Nat) =
    processPoolMethod.
    sum requestsPerCycle:Nat.s_getRequestsPerCycle(requestsPerCycle).
      (taskCounter<requestsPerCycle) -> (
	 sum newTask:Task.s_getRequest(newTask)
	.RequestExecutingAgent_execute(taskCounter+1)
	) <> RequestExecutingAgent_return;
    
proc CreateProcessPool = createProcessPool;
%% creates tasks....
proc RequestClient = 
    r_getRequest(task(1,true,10, LogUpload))
.RequestClient;

%%%%%%% ========== END RequestExecutingAgent 

    
sort ProcessPoolTuple = struct processPoolTuple(__minSize:Nat,__maxSize:Nat,__maxQueuedRequests:Nat, __workersDict:List(Worker), __draining:Bool);


%%% ProcessPool memory
proc ProcessPool_mem(ppt:ProcessPoolTuple) = 
        r_getMaxSize(__maxSize(ppt)).
	  ProcessPool_mem(ppt)
        +
        r_getMinSize(__minSize(ppt)).
        ProcessPool_mem(ppt)
	+
	r_getNumWorkingProcesses(mapGetNumWorkingProcesses(__workersDict(ppt))).
	ProcessPool_mem(ppt)
	+
	r_getNumIdleProcesses(mapGetNumIdleProcesses(__workersDict(ppt))).
	ProcessPool_mem(ppt)
;

proc ProcessPool = Proc_getNumWorkingProcesses.Proc_getNumIdleProcesses.ProcessPool;

proc Proc_getNumWorkingProcesses = 
  s__prListLock_acquire. 
    sum wp:Nat.s_getNumWorkingProcesses(wp).
  s__prListLock_release;

proc Proc_getNumIdleProcesses = 
  s__prListLock_acquire. 
    sum wp:Nat.s_getNumIdleProcesses(wp).
  s__prListLock_release;
  
%% ============ END ProcessPool

%% ============ START WorkingProcess
act r_isWorking, s_isWorking, isWorking:Bool;
act r_taskProcessed, s_taskProcessed, taskProcessed:Nat;
act r_runWatchdogThread, s_runWatchdogThread, runWatchdogThread:Nat#Nat;
act doSomethingWatchdog, doSomethingWorkingProcess;
act r_set__working, s_set__working, set__working:Bool;
act r_runProcessThread, s_runProcessThread, runProcessThread:Nat#Nat;
act r_setTask, s_setTask, setTask:Task;
act processTask, runWorkingProcess, createProcessThread, return;
act r_increaseTaskCounter, s_increaseTaskCounter, increaseTaskCounter;
act r_getStopEvent, s_getStopEvent, getStopEvent:Bool;
act r_clearTask, s_clearTask, clearTask;
act r_joinProcessThread, s_joinProcessThread, joinProcessThread;
act r___pendingQueueGet, s___pendingQueueGet, __pendingQueueGet:Task;
act r___resultsQueuePut, s___resultsQueuePut, __resultsQueuePut:Task;
act r___pendingQueueSize, s___pendingQueueSize, __pendingQueueSize:Nat;
act r_setStopEvent, s_setStopEvent, setStopEvent:Bool;

%%% ============= START Memory for queueues, these are shared between the ProcessPool and the Workers, this is how they communicate

proc Queues_mem(__pendingQueue:List(Task),__resultsQueue:List(Task),__stopEvent:Bool) =   
   r___pendingQueueGet(head(__pendingQueue)).
    Queues_mem(tail(__pendingQueue), __resultsQueue, __stopEvent)
   + 
   sum newTask:Task.r___resultsQueuePut(newTask).
    Queues_mem(__pendingQueue, __resultsQueue<|newTask, __stopEvent) 
      +
    r___pendingQueueSize(#__pendingQueue).
    Queues_mem(__pendingQueue, __resultsQueue, __stopEvent) 
      +
     r_getStopEvent(__stopEvent).
    Queues_mem(__pendingQueue, __resultsQueue, __stopEvent)
      +
    sum newStopEvent:Bool.r_setStopEvent(newStopEvent).
    Queues_mem(__pendingQueue, __resultsQueue, newStopEvent)

;

%%% ============= END Memory for queueues

%%%% === START WorkingProcess 
% 
%%% WorkingProcess Memory
proc WorkingProcess_mem(wpid:Nat, __working:Bool,__taskCounter:Nat,__watchdogThread:Nat, __processThread:Nat,task:Task) = 
      r_isWorking(__working).
      WorkingProcess_mem(wpid, __working, __taskCounter, __watchdogThread, __processThread, task)
    +
      r_taskProcessed(__taskCounter).
      WorkingProcess_mem(wpid, __working, __taskCounter, __watchdogThread, __processThread, task)
    +
      sum working:Bool.r_set__working(working). 
       WorkingProcess_mem(wpid, working, __taskCounter, __watchdogThread, __processThread, task)
    +
      sum newTask:Task.r_setTask(newTask).
     WorkingProcess_mem(wpid, __working, __taskCounter, __watchdogThread, __processThread, newTask)
    +
      r_increaseTaskCounter.
     WorkingProcess_mem(wpid, __working, (__taskCounter+1), __watchdogThread, __processThread, task)
    + 
     r_clearTask.
    WorkingProcess_mem(wpid, __working, __taskCounter, __watchdogThread, __processThread, None)
;

proc WatchdogThread(wpid:Nat, wdtid:Nat) = doSomethingWatchdog.WatchdogThread(wpid,wdtid);  %% TODO: change if os.getppid() == 1:

proc ProcessThread(wpid:Nat, ptid:Nat)= runProcessThread(wpid,ptid).processTask;

proc WorkingProcess(wpid:Nat) = WorkingProcess_start(wpid) || WorkingProcess_mem(wpid,false,0,1,1,None);

%WorkingProcess_start(wpid:Nat) = s_runWatchdogThread(wpid, 1);
proc WorkingProcess_start(wpid:Nat) = runWorkingProcess.WatchdogThread(wpid, 1) || % TODO: like this or with s_runWatchdogThread ?
				WorkingProcess_while(wpid)
				;

proc WorkingProcess_while(wpid:Nat) = 
			sum stopEvent:Bool.s_getStopEvent(stopEvent).sum pqSize:Nat.s___pendingQueueSize(pqSize).
				(!stopEvent && pqSize>0) -> (
					  s_clearTask.
					  s_set__working(true).
					  sum task:Task.s___pendingQueueGet(task). 
					  s_setTask(task). 
					  ProcessThread(wpid,1).			    
					  joinProcessThread.
      %             if not self.task.taskResults() and not self.task.taskException():
					  s___resultsQueuePut(task).
					  s_increaseTaskCounter.
					  s_set__working(false)
				). WorkingProcess_while(wpid)
				<> return 
				;
				    
%% ============ END WorkingProcess

% init block(  { r_getMaxSize, s_getMaxSize, r_getMinSize, s_getMinSize,
% 	  r_getNumWorkingProcesses,s_getNumWorkingProcesses,
% 	  r_getNumIdleProcesses,s_getNumIdleProcesses,
% 	  s__prListLock_acquire, r__prListLock_acquire,
% 	  s__prListLock_release, r__prListLock_release,
% 	  s_isWorking, r_isWorking,
% 	  s_taskProcessed, r_taskProcessed,
% 	  s_runWatchdogThread, r_runWatchdogThread,
% 	  s_set__working, r_set__working,
% 	  r_setTask, s_setTask,
% 	  r_increaseTaskCounter, s_increaseTaskCounter,
% 	  r_runProcessThread, s_runProcessThread,
% 	  r_getStopEvent, s_getStopEvent,
% 	  r_clearTask, s_clearTask,
% 	  r_joinProcessThread, s_joinProcessThread,
% 	  r___pendingQueueGet, s___pendingQueueGet,
% 	  r___resultsQueuePut, s___resultsQueuePut,
% 	  r___pendingQueueSize, s___pendingQueueSize,
% 	  r_setStopEvent, s_setStopEvent,
% 	  s_getRequestsPerCycle, r_getRequestsPerCycle,
% 	  s_getMinProcess, r_getMinProcess,
% 	  s_getMaxProcess, r_getMaxProcess,
% 	  s_getQueueSize, r_getQueueSize,
% 	  s_getRequest, r_getRequest
% 	  },

init allow(  { getMaxSize, getMinSize,
	  getNumWorkingProcesses,
	  getNumIdleProcesses,
	  __prListLock_acquire,
	  __prListLock_release,
	  isWorking,
	  taskProcessed,
	  runWatchdogThread,
	  set__working,
	  setTask,
	  increaseTaskCounter,
	  runProcessThread,
	  getStopEvent,
	  clearTask,
	  joinProcessThread,
	  __pendingQueueGet,
	  __resultsQueuePut,
	  __pendingQueueSize,
	  setStopEvent,
	  getRequestsPerCycle,
	  getMinProcess,
	  getMaxProcess,
	  getQueueSize,
	  r_getRequest,
	  return
	  },
       comm( { r_getMaxSize|s_getMaxSize->getMaxSize,
        r_getMinSize | s_getMinSize -> getMinSize,
        r_getNumWorkingProcesses | s_getNumWorkingProcesses -> getNumWorkingProcesses,
        r_getNumIdleProcesses | s_getNumIdleProcesses -> getNumIdleProcesses,
        s__prListLock_acquire | r__prListLock_acquire -> __prListLock_acquire,
        s__prListLock_release | r__prListLock_release -> __prListLock_release,
        s_isWorking | r_isWorking -> isWorking,
        s_taskProcessed | r_taskProcessed -> taskProcessed,
        s_runWatchdogThread | r_runWatchdogThread -> runWatchdogThread,
	s_set__working | r_set__working -> set__working,
	r_setTask | s_setTask -> setTask,
	r_increaseTaskCounter | s_increaseTaskCounter -> increaseTaskCounter,
	r_runProcessThread | s_runProcessThread -> runProcessThread,
	r_getStopEvent | s_getStopEvent -> getStopEvent,
	r_clearTask | s_clearTask -> clearTask,
	r_joinProcessThread | s_joinProcessThread -> joinProcessThread,
	r___pendingQueueGet | s___pendingQueueGet -> __pendingQueueGet,
	r___resultsQueuePut |  s___resultsQueuePut -> __resultsQueuePut,
	r___pendingQueueSize | s___pendingQueueSize -> __pendingQueueSize,
	r_setStopEvent | s_setStopEvent -> setStopEvent,
	s_getRequestsPerCycle | r_getRequestsPerCycle -> getRequestsPerCycle,
	s_getMinProcess | r_getMinProcess -> getMinProcess,
	s_getMaxProcess | r_getMaxProcess -> getMaxProcess,
	s_getQueueSize | r_getQueueSize -> getQueueSize,
	s_getRequest | r_getRequest -> getRequest

       },
       %% === Agent stuff
       RequestExecutingAgent || RequestClient ||
       
       %% ==== ProcessPool stuff
        ProcessPool || ProcessPool_mem(processPoolTuple(1,8,10,[W(1,false),W(2,false),W(3,false)],false)) || __prListLock || 
% TODO: WorkingProcess memories are not contained (linkedt) to the ProcessPool memory

% 	__pendingQueue:List(Task),__resultsQueue:List(Task),__stopEvent:Bool
        Queues_mem([task(1,true,10, RegisterFile),task(2,true,10, RemoveFile)],[],false)  || 
        ProcessPool || %% TODO: Enable again
        %% === WorkingProcess stuff
% 	wpid:Nat, __working:Bool,__taskCounter:Nat,__watchdogThread:Nat, __processThread:Nat,task:Task
         WorkingProcess(1) || WorkingProcess(2)
     ));
     
     
